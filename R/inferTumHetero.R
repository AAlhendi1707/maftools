#' Clusters variants based on Variant Allele Frequencies (VAF).
#' @description takes output generated by read.maf and clusters variants to infer tumor heterogeneity. This function requires VAF for clustering and density estimation.
#' VAF can be on the scale 0-1 or 0-100. Optionally if copy number information is available, it can be provided as a segmented file (e.g, from Circular Binary Segmentation). Those variants in
#' copy number altered regions will be ignored.
#'
#' @details This function clusters variants based on VAF to estimate univariate density and cluster classification. There are two methods available
#' for clustering. Default using parametric finite mixture models and another method using nonparametric inifinite mixture models (Dirichlet process).
#'
#' @references Chris Fraley and Adrian E. Raftery (2002) Model-based Clustering, Discriminant Analysis and Density Estimation Journal of the American
#' Statistical Association 97:611-631
#'
#' Jara A, Hanson TE, Quintana FA, Muller P, Rosner GL. DPpackage: Bayesian Semi- and Nonparametric Modeling in R. Journal of statistical software. 2011;40(5):1-30.
#'
#' Olshen AB, Venkatraman ES, Lucito R, Wigler M. Circular binary segmentation for the analysis of array-based DNA copy number data. Biostatistics. 2004;5(4):557-72.
#'
#' @param maf an \code{\link{MAF}} object generated by \code{\link{read.maf}}
#' @param vafCol manually specify column name for vafs. Default looks for column 't_vaf'
#' @param tsb specify sample names (Tumor_Sample_Barcodes) for which clustering has to be done.
#' @param dirichlet If TRUE uses nonparametric dirichlet process for clustering. Default FALSE, uses finite mixture models.
#' @param minVaf filter low frequency variants. Low vaf variants maybe due to sequencing error. Default 0. (on the scale of 0 to 1)
#' @param maxVaf filter high frequency variants. High vaf variants maybe due to copy number alterations or impure tumor. Default 1. (on the scale of 0 to 1)
#' @param ignChr ignore these chromosomes from analysis. e.g, sex chromsomes chrX, chrY. Default NULL.
#' @param top if \code{tsb} is NULL, uses top n number of most mutated samples. Defaults to 5.
#' @param segFile path to CBS segmented copy number file. Column names should be Sample, Chromosome, Start, End, Num_Probes and Segment_Mean (log2 scale).
#' @return list of clustering tables.
#' @examples
#' laml.maf <- system.file("extdata", "tcga_laml.maf.gz", package = "maftools")
#' laml <- read.maf(maf = laml.maf, removeSilent = TRUE, useAll = FALSE)
#' TCGA.AB.2972.clust <- inferHeterogeneity(maf = laml, tsb = 'TCGA.AB.2972', vafCol = 'i_TumorVAF_WU')
#'
#' @importFrom mclust densityMclust
#' @importFrom DPpackage DPdensity
#' @export
#' @seealso \code{\link{plotClusters}}

inferHeterogeneity = function(maf, tsb = NULL, top = 5, vafCol = NULL, dirichlet = FALSE, segFile = NULL, ignChr = NULL, minVaf = 0, maxVaf = 1){

  #Main data
  dat = maf@data

  #chromosme 1 to 22
  onlyContigs = as.character(seq(1:22))

  #Check if t_vaf exists
  if(!'t_vaf' %in% colnames(dat)){
    if(is.null(vafCol)){
      print(colnames(dat))
      stop('t_vaf field is missing. Use addReadCounts to add read-depth and vaf info, Or use argument vafCol to manually specify vaf column name.')
    }else{
      colnames(dat)[which(colnames(dat) == vafCol)] = 't_vaf'
    }
  }

  #If tsb is not specified, choose top n samples.
  if(is.null(tsb)){
    tsb = as.character(maf@variants.per.sample[1:top,Tumor_Sample_Barcode])
  }

  #Copynumber data : Read and Sort
  if(!is.null(segFile)){
    seg.dat = readSegs(segFile)
    seg.dat$Chromosome = gsub(pattern = 'chr', replacement = '', x = seg.dat$Chromosome, fixed = TRUE)
    seg.dat = seg.dat[!Chromosome %in% c('X', 'Y')]
    seg.dat = seg.dat[Chromosome %in% onlyContigs]
    seg.dat = seg.dat[order(as.numeric(Chromosome))]
    setkey(x = seg.dat, Chromosome, Start_Position, End_Position)

    seg.tsbs = unique(seg.dat[,Sample])

    #Match sample names from segmentation files to maf file
    tsb = seg.tsbs[seg.tsbs %in% as.character(maf@variants.per.sample[,Tumor_Sample_Barcode])]
    tsb.mismatch = seg.tsbs[!seg.tsbs %in% as.character(maf@variants.per.sample[,Tumor_Sample_Barcode])]
    if(length(tsb) > 0){
      message('Copy number data found for samples:')
      print(tsb)
      if(length(tsb.mismatch) > 0){
        message('Removed mismatch samples:')
        print(tsb.mismatch)
      }
    }else{
      message('Sample names from Segmentation file:')
      print(seg.tsbs)
      message('Sample names from MAF:')
      print(as.character(maf@variants.per.sample[,Tumor_Sample_Barcode]))
      stop('Sample names from segmentation file do not match to maf file.')
    }
  }

  #empty df to store cluster info
  clust.dat = c()

  #select only tsbs from main data
  dat.tsb = dat[Tumor_Sample_Barcode %in% tsb]

  if(nrow(dat.tsb) < 1){
    stop(paste(tsb, 'not found in MAF'))
  }

  #Some TCGA studies have Start_Position and End_Position set to as 'position'. Change if so.
  if(length(grep(pattern = 'Start_position', x = colnames(dat.tsb))) > 0){
    colnames(dat.tsb)[which(colnames(dat.tsb) == 'Start_position')] = 'Start_Position'
  }

  if(length(grep(pattern = 'End_position', x = colnames(dat.tsb))) > 0){
    colnames(dat.tsb)[which(colnames(dat.tsb) == 'End_position')] = 'End_Position'
  }

  #Select only required columns and sort
  dat.tsb = dat.tsb[,.(Hugo_Symbol, Chromosome, Start_Position, End_Position, Tumor_Sample_Barcode, t_vaf)]
  dat.tsb = dat.tsb[order(Chromosome)]
  dat.tsb$Chromosome = as.character(dat.tsb$Chromosome)
  #setkey(x = dat.tsb, Chromosome, Start_Position, End_Position)

  #If VAF is in %, covert it to fractions.
  if(max(dat.tsb$t_vaf, na.rm = TRUE) > 1){
    dat.tsb$t_vaf = dat.tsb$t_vaf/100
  }

  #Filter ignChr
  if(!is.null(ignChr)){
    dat.tsb = dat.tsb[!Chromosome %in% ignChr]
  }

  #Filter low and high vaf variants
  dat.tsb = dat.tsb[t_vaf > minVaf]
  dat.tsb = dat.tsb[t_vaf < maxVaf]

  #Change contig names 'chr' to numeric in maf (so it can match to copynumber data)
  dat.tsb$Chromosome = gsub(pattern = 'chr', replacement = '', x = dat.tsb$Chromosome, fixed = TRUE)
  dat.tsb = suppressWarnings(dat.tsb[order(as.numeric(Chromosome))]) #Generates warning for X and Y sorting, as numeric


  ################# Map variants to segments and start clustering #######################

  for(i in 1:length(tsb)){

    #tsb.dat = dat.tsb[dat.tsb$Tumor_Sample_Barcode == tsb[i],]
    tsb.dat = dat.tsb[Tumor_Sample_Barcode == tsb[i]]
    tsb.dat = tsb.dat[!is.na(tsb.dat$t_vaf),]

    #nvm this. Variable for later use
    tempCheck = 0

    if(!is.null(segFile)){

      seg = seg.dat[Sample %in% tsb[i]]

      if(nrow(seg) < 1){
        stop(paste('No copynumber data found for sample', tsb[i], sep = ' '))
      }else{

        #Overlap variants with segment data
        tsb.dat = foverlaps(x = tsb.dat, y = seg, by.x = c('Chromosome', 'Start_Position', 'End_Position'))
        tsb.dat = tsb.dat[,.(Hugo_Symbol, Chromosome, i.Start_Position, i.End_Position,
                             Tumor_Sample_Barcode, t_vaf, Start_Position, End_Position, Segment_Mean)]
        colnames(tsb.dat)[c(3:4, 7:8)] = c('Start_Position', 'End_Position', 'Segment_Start', 'Segment_End')

        #Convert log scale to absolute copynumber data
        suppressWarnings(tsb.dat[,CN := 2^(Segment_Mean)*2])

        if(nrow(tsb.dat[is.na(tsb.dat$CN)]) > 0){
          message(paste('Removed ', nrow(tsb.dat[is.na(tsb.dat$CN)]), ' variants with no copy number data.', sep = ''))
          print(tsb.dat[is.na(tsb.dat$CN)])
          tsb.dat = tsb.dat[!is.na(tsb.dat$CN)]
        }

        #Remove copy number altered variants.
        tsb.dat.cn.vars = tsb.dat[!CN >1.5 & CN < 2.5]
        if(nrow(tsb.dat.cn.vars) > 0){
          message('Copy number altered variants:')
          tsb.dat.cn.vars$cluster = 'CN_altered'
          print(tsb.dat.cn.vars)
          tempCheck = 1
        }
        tsb.dat = tsb.dat[CN >1.5 & CN < 2.5] #Copy number neutral variants
      }
    }

    #cluster

    if(dirichlet){

      #Awesome blog post on non-finite mixture models
      #http://blog.echen.me/2012/03/20/infinite-mixture-models-with-nonparametric-bayes-and-the-dirichlet-process/

      #Initiate mcmc parameters
      nburn = 1000
      nsave = 10000
      nskip = 20
      ndisplay = 1000
      mcmc = list(nburn=nburn,nsave=nsave,nskip=nskip,ndisplay=ndisplay)
      #Hyper parameters
      prior1 = list(alpha=0.05,m1=rep(0,1),psiinv1=diag(0.5,1),nu1=6,tau1=0.2,tau2=1000)
      #Run main function
      dp = DPpackage::DPdensity(y = tsb.dat[,t_vaf]*100, prior = prior1, mcmc = mcmc, status = TRUE)
      #Assign clusters
      tsb.dat$cluster = as.character(dp$state$ss)
    }else{
      #More than 7 clusters possible ? May not be biologically meaningful.
      #Use finite mixture model
      tsb.cluster = mclust::densityMclust(tsb.dat[,t_vaf], G = 1:7)
      tsb.dat$cluster = as.character(tsb.cluster$classification)
    }

    #Refine cluster assignment (z score > 2; mark it as an outlier)
    tsb.dat = refineClusters(clusters = tsb.dat)

    if(tempCheck == 1){
      tsb.dat = rbind(tsb.dat, tsb.dat.cn.vars)
    }

    #Update result table
    clust.dat = rbind(clust.dat, tsb.dat)

  }

  #Caluclate cluster means
  clust.dat.mean = clust.dat[,mean(t_vaf), by = .(Tumor_Sample_Barcode, cluster)]
  colnames(clust.dat.mean)[ncol(clust.dat.mean)] = 'meanVaf'

  return(list(clusterData = clust.dat, clusterMeans = clust.dat.mean))
}
