#' draw an oncoplot
#' @description takes output generated by read.maf and draws an oncoplot (aka waterfall plot).
#'
#' @details
#' Takes maf file as input and plots it as a matrix. Any desired annotations can be added at the bottom of the oncoplot by providing \code{annotation}
#'
#' @param maf an MAF object generated by \code{\link{read.maf}}
#' @param writeMatrix writes oncomatrix to output file.
#' @param top how many top genes to be drawn. defaults to 20.
#' @param drawRowBar logical plots barplot for each gene.
#' @param drawColBar logical plots barplot for each sample.
#' @param showTumorSampleBarcodes logical to include sample names.
#' @param annotation data.frame with first column containing Tumor_Sample_Barcodes and rest of columns with annotations.
#' @param genesToIgnore do not show these genes in Oncoplot. Default NULL.
#' @param removeNonMutated Logical. If \code{TRUE} removes samples with no mutations in the oncoplot for better visualization. Default \code{FALSE}.
#' @param colors named vector of colors for each Variant_Classification.
#' @export


oncoplot = function (maf, writeMatrix = FALSE, top = 20, bg = "#CCCCCC", drawRowBar = T, drawColBar = T,
                     showTumorSampleBarcodes = FALSE, annotation = NULL, genesToIgnore = NULL, removeNonMutated = F, colors = NULL) {

  #set seed for consistancy.
  set.seed(seed = 1024)

  require(package = "ComplexHeatmap", quietly = T, warn.conflicts = F)
  require(package = "RColorBrewer", quietly = T, warn.conflicts = F)

  numMat = maf@numericMatrix
  mat_origin = maf@oncoMatrix

  #remove genes from genesToIgnore if any
  if(!is.null(genesToIgnore)){
    mat_origin = mat_origin[!rownames(mat_origin) %in% genesToIgnore,]
  }

  #choose user defined nuber of top genes
  if(nrow(mat_origin) < top){
    mat = mat_origin
  }else{
    mat = mat_origin[1:top, ]
  }

  #hard coded colors for variant classification if user doesnt provide any
  if(is.null(colors)){
    col = c(brewer.pal(12,name = "Paired"),brewer.pal(11,name = "Spectral")[1:3],'black')
    names(col) = names = c('Nonstop_Mutation','Frame_Shift_Del','Silent','Missense_Mutation','IGR','Nonsense_Mutation',
                           'RNA','Splice_Site','Intron','Frame_Shift_Ins','In_Frame_Dell','In_Frame_Del','ITD','In_Frame_Ins','Translation_Start_Site',"Multi_Hit")
  }else{
    col = colors
  }

  variant.classes = unique(unlist(as.list(apply(mat_origin, 2, unique))))

  type_col = structure(col[variant.classes], names = names(col[variant.classes]))
  type_col = type_col[!is.na(type_col)]

  type_name = structure(variant.classes, names = variant.classes)

  #annotation if given
  if(!is.null(annotation)){
    annotation[,1] = gsub(pattern = '-', replacement = '.', x = annotation[,1])
    rownames(annotation) = annotation[,1]
    annotation = annotation[colnames(mat_origin),]
    annotation = annotation[complete.cases(annotation),]
    anno.df = data.frame(row.names = annotation[,1])
    anno.df = cbind(anno.df, annotation[,2:ncol(annotation)])
    colnames(anno.df) = colnames(annotation)[2:ncol(annotation)]
    bot.anno = HeatmapAnnotation(anno.df)
  }

  if (writeMatrix) {
    write.table(mat_origin, "onco_matrix.txt", sep = "\t", quote = F)
  }

  oncoPlot = TRUE #Change later

  if (oncoPlot) {
  #This is from oncoPrint source code form ComplexHeatmap
    add_oncoprint = function(type, x, y, width, height) {
      for (i in 1:length(variant.classes)) {
        if (any(type %in% variant.classes[i])) {
          grid.rect(x, y, width - unit(0.5, "mm"), height -
                      unit(1, "mm"), gp = gpar(col = NA, fill = type_col[variant.classes[i]]))
        }
      }
      if (any(type %in% "")) {
        grid.rect(x, y, width - unit(0.5, "mm"), height -
                    unit(1, "mm"), gp = gpar(col = NA, fill = bg))
      }
    }

    anno_pct = function(index) {
      n = length(index)
      pct = apply(mat_origin[rev(index), ], 1, function(x) sum(!grepl("^\\s*$", x))/length(x)) * 100
      pct = paste0(round(pct), "%")
      pushViewport(viewport(xscale = c(0, 1), yscale = c(0.5, n + 0.5)))
      grid.text(pct, x = 1, y = seq_along(index), default.units = "native",
                just = "right", gp = gpar(fontsize = 10))
      upViewport()
    }

    ha_pct = HeatmapAnnotation(pct = anno_pct, width = grobWidth(textGrob("100%", gp = gpar(fontsize = 10))), which = "row")

    anno_row_bar = function(index) {
      n = length(index)
      tb = apply(mat[rev(index), ], 1, function(x) {
        x = unlist(strsplit(x, ";"))
        x = x[!grepl("^\\s*$", x)]
        x = sort(x)
        table(x)
      })
      max_count = max(sapply(tb, sum))
      pushViewport(viewport(xscale = c(0, max_count * 1.1), yscale = c(0.5, n + 0.5)))
      for (i in seq_along(tb)) {
        if (length(tb[[i]])) {
          x = cumsum(tb[[i]])
          grid.rect(x, i, width = tb[[i]], height = 0.8,
                    default.units = "native", just = "right",
                    gp = gpar(col = NA, fill = type_col[names(tb[[i]])]))
        }
      }
      breaks = grid.pretty(c(0, max_count))
      grid.xaxis(at = breaks, label = breaks, main = FALSE,
                 gp = gpar(fontsize = 10))
      upViewport()
    }

    ha_row_bar = HeatmapAnnotation(row_bar = anno_row_bar, width = unit(4, "cm"), which = "row")

    anno_column_bar = function(index) {
      n = length(index)
      tb = apply(mat_origin[, index], 2, function(x) {
        x = unlist(strsplit(x, ";"))
        x = x[!grepl("^\\s*$", x)]
        x = sort(x)
        table(x)
      })
      max_count = max(sapply(tb, sum))
      pushViewport(viewport(yscale = c(0, max_count * 1.1),
                            xscale = c(0.5, n + 0.5)))
      for (i in seq_along(tb)) {
        if (length(tb[[i]])) {
          y = cumsum(tb[[i]])
          grid.rect(i, y, height = tb[[i]], width = 0.8,
                    default.units = "native", just = "top", gp = gpar(col = NA, fill = type_col[names(tb[[i]])]))
        }
      }
      breaks = grid.pretty(c(0, max_count))
      grid.yaxis(at = breaks, label = breaks, gp = gpar(fontsize = 10))
      upViewport()
    }

    ha_column_bar = HeatmapAnnotation(column_bar = anno_column_bar, which = "column")

    #To remove samples with no mutations in top n genes, if user says switches removeNonMutated
    if(removeNonMutated){
      numMat = numMat[rownames(mat),]
      numMat = numMat[,colnames(mat)]
      tsb = colnames(numMat)
      tsb.exclude = colnames(numMat[,colSums(numMat) == 0])
      tsb.include = tsb[!tsb %in% tsb.exclude]
      mat = mat[,tsb.include]
    }


    if(drawColBar){
      if(is.null(annotation)){
        ht = Heatmap(mat, rect_gp = gpar(type = "none"), cell_fun = function(j, i, x, y, width, height, fill) {
          type = mat[i, j]
          add_oncoprint(type, x, y, width, height)},
          row_names_gp = gpar(fontsize = 10), show_column_names = showTumorSampleBarcodes,
          show_heatmap_legend = FALSE, top_annotation = ha_column_bar,
          top_annotation_height = unit(2, "cm"))
      } else{
        ht = Heatmap(mat, rect_gp = gpar(type = "none"), cell_fun = function(j, i, x, y, width, height, fill) {
          type = mat[i, j]
          add_oncoprint(type, x, y, width, height)},
          row_names_gp = gpar(fontsize = 10), show_column_names = showTumorSampleBarcodes,
          show_heatmap_legend = FALSE, top_annotation = ha_column_bar,
          top_annotation_height = unit(2, "cm"), bottom_annotation = bot.anno)
      }

    } else{
      if(is.null(annotation)){
        ht = Heatmap(mat, rect_gp = gpar(type = "none"), cell_fun = function(j, i, x, y, width, height, fill) {
          type = mat[i, j]
          add_oncoprint(type, x, y, width, height)},
          row_names_gp = gpar(fontsize = 10), show_column_names = showTumorSampleBarcodes, show_heatmap_legend = FALSE)
      }else{
        ht = Heatmap(mat, rect_gp = gpar(type = "none"), cell_fun = function(j, i, x, y, width, height, fill) {
          type = mat[i, j]
          add_oncoprint(type, x, y, width, height)},
          row_names_gp = gpar(fontsize = 10), show_column_names = showTumorSampleBarcodes, show_heatmap_legend = FALSE, bottom_annotation = bot.anno)
      }
    }

    ht_list = ha_pct + ht


    if(drawRowBar){
      ht_list =  ht_list + ha_row_bar
    }

    legend = legendGrob(labels = type_name[names(type_col)],  pch = 15, gp = gpar(col = type_col), nrow = 2)

    draw(ht_list, newpage = FALSE, annotation_legend_side = "bottom", annotation_legend_list = list(legend))
  }
}
