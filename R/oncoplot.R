#' draw an oncoplot
#' @description takes output generated by read.maf and draws an oncoplot (aka waterfall plot).
#'
#' @details
#' Takes maf file as input and plots it as a matrix. Any desired annotations can be added at the bottom of the oncoplot by providing \code{annotation}
#'
#' @param maf an MAF object generated by \code{read.maf}
#' @param logical default TRUE
#' @param writeMatrix writes oncomatrix to output file.
#' @param top how many top genes to be drawn. defaults to 20.
#' @param drawRowBar logical plots barplot for each gene.
#' @param drawColBar logical plots barplot for each sample.
#' @param showTumorSampleBarcodes logical to include sample names.
#' @param annotation data.frame with first column containing Tumor_Sample_Barcodes and rest of columns with annotations.
#' @export


oncoplot = function (maf, oncoPlot = TRUE, writeMatrix = FALSE, top = 20, bg = "#CCCCCC", drawRowBar = T, drawColBar = T,
                     showTumorSampleBarcodes = FALSE, annotation = NULL, annotationColor = NULL , genesToIgnore = NULL) {

  #set seed for consistancy.
  set.seed(seed = 1024)

  require(package = "ComplexHeatmap", quietly = T, warn.conflicts = F)
  require(package = "RColorBrewer", quietly = T, warn.conflicts = F)

  mat_origin = maf@oncoMatrix

  #remove genes from genesToIgnore if any
  if(!is.null(genesToIgnore)){
    mat_origin = mat_origin[!rownames(mat_origin) %in% genesToIgnore,]
  }

  #choose user defined nuber of top genes
  if(nrow(mat_origin) < top){
    mat = mat_origin
  }else{
    mat = mat_origin[1:top, ]
  }

  #hard coded colors for variant classification
  col = c('#CCCCCC',brewer.pal(12, name = "Paired"), brewer.pal(11, name = "Spectral")[1:3], "maroon")
  names(col) = names = c('',"Nonstop_Mutation", "Frame_Shift_Del",
                         "Intron", "Missense_Mutation", "IGR", "Nonsense_Mutation",
                         "RNA", "Splice_Site", "In_Frame_Del", "Frame_Shift_Ins",
                         "Silent", "In_Frame_Ins", "ITD", "3'UTR", "Translation_Start_Site",
                         "two_hit")

  variant.classes = unique(unlist(as.list(apply(mat_origin, 2, unique))))

  type_col = structure(col[variant.classes], names = names(col[variant.classes]))
  type_name = structure(variant.classes, names = variant.classes)

  #annotation if given
  if(!is.null(annotation)){
    annotation[,1] = gsub(pattern = '-', replacement = '.', x = annotation[,1])
    rownames(annotation) = annotation[,1]
    annotation = annotation[colnames(mat_origin),]
    annotation = annotation[complete.cases(annotation),]
    anno.df = data.frame(row.names = annotation[,1])
    anno.df = cbind(anno.df, annotation[,2:ncol(annotation)])
    colnames(anno.df) = colnames(annotation)[2:ncol(annotation)]
    bot.anno = HeatmapAnnotation(anno.df)
  }

  if (writeMatrix) {
    write.table(mat_origin, "onco_matrix.txt", sep = "\t", quote = F)
  }

  if (oncoPlot) {
  #This is from oncoPrint source code form ComplexHeatmap
    add_oncoprint = function(type, x, y, width, height) {
      for (i in 1:length(variant.classes)) {
        if (any(type %in% variant.classes[i])) {
          grid.rect(x, y, width - unit(0.5, "mm"), height -
                      unit(1, "mm"), gp = gpar(col = NA, fill = type_col[variant.classes[i]]))
        }
      }
      if (any(type %in% "")) {
        grid.rect(x, y, width - unit(0.5, "mm"), height -
                    unit(1, "mm"), gp = gpar(col = NA, fill = bg))
      }
    }

    anno_pct = function(index) {
      n = length(index)
      pct = apply(mat_origin[rev(index), ], 1, function(x) sum(!grepl("^\\s*$", x))/length(x)) * 100
      pct = paste0(round(pct), "%")
      pushViewport(viewport(xscale = c(0, 1), yscale = c(0.5, n + 0.5)))
      grid.text(pct, x = 1, y = seq_along(index), default.units = "native",
                just = "right", gp = gpar(fontsize = 10))
      upViewport()
    }

    ha_pct = HeatmapAnnotation(pct = anno_pct, width = grobWidth(textGrob("100%", gp = gpar(fontsize = 10))), which = "row")

    anno_row_bar = function(index) {
      n = length(index)
      tb = apply(mat[rev(index), ], 1, function(x) {
        x = unlist(strsplit(x, ";"))
        x = x[!grepl("^\\s*$", x)]
        x = sort(x)
        table(x)
      })
      max_count = max(sapply(tb, sum))
      pushViewport(viewport(xscale = c(0, max_count * 1.1), yscale = c(0.5, n + 0.5)))
      for (i in seq_along(tb)) {
        if (length(tb[[i]])) {
          x = cumsum(tb[[i]])
          grid.rect(x, i, width = tb[[i]], height = 0.8,
                    default.units = "native", just = "right",
                    gp = gpar(col = NA, fill = type_col[names(tb[[i]])]))
        }
      }
      breaks = grid.pretty(c(0, max_count))
      grid.xaxis(at = breaks, label = breaks, main = FALSE,
                 gp = gpar(fontsize = 10))
      upViewport()
    }

    ha_row_bar = HeatmapAnnotation(row_bar = anno_row_bar, width = unit(4, "cm"), which = "row")

    anno_column_bar = function(index) {
      n = length(index)
      tb = apply(mat_origin[, index], 2, function(x) {
        x = unlist(strsplit(x, ";"))
        x = x[!grepl("^\\s*$", x)]
        x = sort(x)
        table(x)
      })
      max_count = max(sapply(tb, sum))
      pushViewport(viewport(yscale = c(0, max_count * 1.1),
                            xscale = c(0.5, n + 0.5)))
      for (i in seq_along(tb)) {
        if (length(tb[[i]])) {
          y = cumsum(tb[[i]])
          grid.rect(i, y, height = tb[[i]], width = 0.8,
                    default.units = "native", just = "top", gp = gpar(col = NA, fill = type_col[names(tb[[i]])]))
        }
      }
      breaks = grid.pretty(c(0, max_count))
      grid.yaxis(at = breaks, label = breaks, gp = gpar(fontsize = 10))
      upViewport()
    }

    ha_column_bar = HeatmapAnnotation(column_bar = anno_column_bar, which = "column")

    if(drawColBar){
      if(is.null(annotation)){
        ht = Heatmap(mat, rect_gp = gpar(type = "none"), cell_fun = function(j, i, x, y, width, height, fill) {
          type = mat[i, j]
          add_oncoprint(type, x, y, width, height)},
          row_names_gp = gpar(fontsize = 10), show_column_names = showTumorSampleBarcodes,
          show_heatmap_legend = FALSE, top_annotation = ha_column_bar,
          top_annotation_height = unit(2, "cm"))
      } else{
        ht = Heatmap(mat, rect_gp = gpar(type = "none"), cell_fun = function(j, i, x, y, width, height, fill) {
          type = mat[i, j]
          add_oncoprint(type, x, y, width, height)},
          row_names_gp = gpar(fontsize = 10), show_column_names = showTumorSampleBarcodes,
          show_heatmap_legend = FALSE, top_annotation = ha_column_bar,
          top_annotation_height = unit(2, "cm"), bottom_annotation = bot.anno)
      }

    } else{
      if(is.null(annotation)){
        ht = Heatmap(mat, rect_gp = gpar(type = "none"), cell_fun = function(j, i, x, y, width, height, fill) {
          type = mat[i, j]
          add_oncoprint(type, x, y, width, height)},
          row_names_gp = gpar(fontsize = 10), show_column_names = showTumorSampleBarcodes, show_heatmap_legend = FALSE)
      }else{
        ht = Heatmap(mat, rect_gp = gpar(type = "none"), cell_fun = function(j, i, x, y, width, height, fill) {
          type = mat[i, j]
          add_oncoprint(type, x, y, width, height)},
          row_names_gp = gpar(fontsize = 10), show_column_names = showTumorSampleBarcodes, show_heatmap_legend = FALSE, bottom_annotation = bot.anno)
      }
    }

    ht_list = ha_pct + ht


    if(drawRowBar){
      ht_list =  ht_list + ha_row_bar
    }

    legend = legendGrob(labels = type_name[names(type_col)],  pch = 15, gp = gpar(col = type_col), nrow = 1)

    draw(ht_list, newpage = FALSE, annotation_legend_side = "bottom", annotation_legend_list = list(legend))
  }
}
