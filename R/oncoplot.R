#' draw an oncoplot
#' @description takes output generated by read.maf and draws an oncoplot (aka waterfall plot).
#'
#' @details
#' Takes maf file as input and plots it as a matrix. Any desired annotations can be added at the bottom of the oncoplot by providing \code{annotation}.
#' Oncoplot can be sorted either by mutations or annotations using arguments \code{sortByMutation} and \code{sortByAnnotation} respectively.
#'
#' Thanks to Ryan Morin for \code{sortByAnnotation} code.
#'
#'
#' @param maf an \code{\link{MAF}} object generated by \code{\link{read.maf}}
#' @param top how many top genes to be drawn. defaults to 20.
#' @param genes Just draw oncoplot for these genes. Default NULL.
#' @param mutsig Mutsig resuts if availbale. Usually file named sig_genes.txt If provided plots significant genes and correpsonding Q-values as side row-bar. Default NULL.
#' @param mutsigQval Q-value to choose significant genes from mutsig results. Default 0.1
#' @param drawRowBar logical plots barplot for each gene. Default \code{TRUE}.
#' @param drawColBar logical plots barplot for each sample. Default \code{TRUE}.
#' @param showTumorSampleBarcodes logical to include sample names.
#' @param annotationCols columns names from `annotation` slot of \code{MAF} to be drawn in the plot. Dafault NULL.
#' @param annotationDat If MAF file was read without annotations, provide a custom \code{data.frame} with a column containing Tumor_Sample_Barcodes along with rest of columns with annotations.
#' You can specify which columns to be drawn using `annotationCols` argument.
#' @param genesToIgnore do not show these genes in Oncoplot. Default NULL.
#' @param annotationColor list of colors to use for annotation. Default NULL.
#' @param removeNonMutated Logical. If \code{TRUE} removes samples with no mutations in the oncoplot for better visualization. Default \code{TRUE}.
#' @param colors named vector of colors for each Variant_Classification.
#' @param fontSize font size for gene names. Default 10.
#' @param sortByMutation Helpful in case of MAF was read along with copy number data. Default FALSE.
#' @param sortByAnnotation logical sort oncomatrix by provided annotations. Defaults to FALSE. This is mutually exclusive with sortByMutation.
#' @param writeMatrix writes character coded matrix used to generate the plot to an output file. This can be used as an input
#' for ComplexHeatmap \link[ComplexHeatmap]{oncoPrint} function if you wish to customize the plot.
#' @return None.
#' @examples
#' laml.maf <- system.file("extdata", "tcga_laml.maf.gz", package = "maftools")
#' laml <- read.maf(maf = laml.maf)
#' oncoplot(maf = laml, top = 3)
#' @import ComplexHeatmap
#' @import grid
#' @seealso \code{\link{oncostrip}}
#' @export


oncoplot = function (maf, top = 20, genes = NULL, mutsig = NULL, mutsigQval = 0.1, drawRowBar = TRUE, drawColBar = TRUE,
                     annotationCols = NULL, annotationDat = NULL, annotationColor = NULL, genesToIgnore = NULL, showTumorSampleBarcodes = FALSE,
                      removeNonMutated = TRUE, colors = NULL, fontSize = 10, sortByMutation = FALSE, sortByAnnotation = FALSE, writeMatrix = FALSE) {

  #set seed for consistancy.
  set.seed(seed = 1024)

  #-------------------------------------Preprocess matrix---------------------------------------------------

  if(!is.null(genes)){ #If user provides a gene list

    om = createOncoMatrix(m = maf, g = genes)
    numMat = om$numericMatrix
    mat_origin = om$oncoMatrix
  } else if(!is.null(mutsig)){ #If user provides significant gene table (e.g; mutsig results)

    if(as.logical(length(grep(pattern = 'gz$', x = mutsig, fixed = FALSE)))){
      #If system is Linux use fread, else use gz connection to read gz file.
      if(Sys.info()[['sysname']] == 'Windows'){
        mutsigResults.gz = gzfile(description = mutsig, open = 'r')
        suppressWarnings(ms <- data.table::as.data.table(read.csv(file = mutsigResults.gz, header = TRUE, sep = '\t', stringsAsFactors = FALSE, comment.char = '#')))
        close(mutsigResults.gz)
      } else{
        ms = suppressWarnings(data.table::fread(input = paste('zcat <', mutsig), sep = '\t', stringsAsFactors = FALSE, verbose = FALSE, data.table = TRUE, showProgress = TRUE, header = TRUE))
      }
    } else{
      ms = data.table::fread(input = mutsig, sep = '\t', stringsAsFactors = FALSE, header = TRUE)
    }

    ms$q = as.numeric(gsub(pattern = "^<", replacement = "", x = as.character(ms$q)))
    ms[,FDR := -log10(as.numeric(as.character(q)))]
    mach.epsi = .Machine$double.eps
    ms$q = ifelse(test = ms$q == 0, yes = mach.epsi, no = ms$q)
    ms.smg = ms[q < mutsigQval]
    genes = as.character(ms[q < mutsigQval, gene])

    om = createOncoMatrix(m = maf, g = genes)
    numMat = om$numericMatrix
    mat_origin = om$oncoMatrix

    #Check for any missing genes and ignore them if necessary
    if(length(genes[!genes %in% rownames(numMat)]) > 0){
      message('Following genes from MutSig results are not available in MAF:')
      print(genes[!genes %in% rownames(numMat)])
      message('Ignoring them.')
      genes = genes[ms.smg.genes %in% rownames(numMat)]
      ms.smg = ms.smg[gene %in% ms.smg.genes]
    }

    ms.smg = ms.smg[,.(gene, FDR)]
    ms.smg = data.frame(row.names = ms.smg$gene, FDR = ms.smg$FDR)
  }else { #If user does not provide gene list or MutSig results, draw TOP (default 20) genes

    genes = getGeneSummary(x = maf)[1:top, Hugo_Symbol]
    om = createOncoMatrix(m = maf, g = genes)
    numMat = om$numericMatrix
    mat_origin = om$oncoMatrix
  }

  #Annotations
  if(!is.null(annotationCols)){
    if(!is.null(annotationDat)){
      data.table::setDF(annotationDat)
      if(length(annotationCols[!annotationCols %in% colnames(annotationDat)]) > 0){
        message('Following columns are missing from provided annotation data. Ignoring them..')
        print(annotationCols[!annotationCols %in% colnames(annotationDat)])
        annotationCols = annotationCols[annotationCols %in% colnames(annotationDat)]
        if(length(annotationCols) == 0){
          stop('Zero annotaions to add! Make at-least one of the provided annotationCols are present in annotationDat')
        }
      }
      annotation = annotationDat[,c('Tumor_Sample_Barcode', annotationCols)]
      annotation = data.frame(row.names = annotation$Tumor_Sample_Barcode ,annotation[,annotationCols, drop = FALSE])
    } else{
      annotationDat = getAnnotations(x = maf)
      #data.table::setDF(annotationDat)
      if(length(annotationCols[!annotationCols %in% colnames(annotationDat)]) > 0){
        message('Following columns are missing from annotation slot of MAF. Ignoring them..')
        print(annotationCols[!annotationCols %in% colnames(annotationDat)])
        annotationCols = annotationCols[annotationCols %in% colnames(annotationDat)]
        if(length(annotationCols) == 0){
          message('Make sure at-least one of the values from provided annotationCols are present in annotation slot of MAF. Here are available annotaions from MAF..')
          print(head(getAnnotations(maf)))
          stop('Zero annotaions to add! You can also provide custom annotations via annotationDat argument.')
        }
      }
      annotation = data.frame(row.names = annotationDat$Tumor_Sample_Barcode ,annotationDat[,annotationCols, with = FALSE])
    }
  }

  #--Sort

  if(length(genes[!genes %in% rownames(numMat)]) > 0){
    message('Following genes from provided gene list are missing from MAF:')
    print(genes[!genes %in% rownames(numMat)])
    message('Ignoring them.')
    genes = genes[genes %in% rownames(numMat)]

    if(length(genes) < 1){
      stop('Only one gene left! At-least two genes required for plotting.')
    }
  }

  if(sortByAnnotation){
    if(is.null(annotation)){
      stop("Missing annotation data. Use argument `annotation` to provide annotations.")
    }
    numMat = sortByAnnotation(numMat = numMat, maf = maf, annotation)
  }else{
    numMat = sortByMutation(numMat = numMat, maf = maf)
  }

  mat = mat_origin[rownames(numMat), , drop = FALSE]
  mat = mat[,colnames(numMat), drop = FALSE]

  #---remove genes from genesToIgnore if any
  if(!is.null(genesToIgnore)){
    numMat = numMat[!rownames(numMat) %in% genesToIgnore,]
    mat_origin = mat_origin[!rownames(mat_origin) %in% genesToIgnore,]
  }

  #If <2 samples stop !
  if(ncol(numMat) < 2){
    stop('Cannot create oncoplot for single sample. Minimum two sample required ! ')
  }

  #If <2 samples stop !
  if(nrow(numMat) < 2){
    stop('Cannot create oncoplot for single gene. Minimum two genes required ! ')
  }
  #-----------------------

  #To remove samples with no mutations in top n genes, if user says removeNonMutated
  if(removeNonMutated){
    numMat = numMat[rownames(mat), , drop = FALSE]
    numMat = numMat[,colnames(mat), drop = FALSE]
    tsb = colnames(numMat)
    tsb.exclude = colnames(numMat[,colSums(numMat) == 0, drop = FALSE])
    tsb.include = tsb[!tsb %in% tsb.exclude]
    mat = mat[,tsb.include, drop = FALSE]
  }

  if (writeMatrix) {
    write.table(mat, "onco_matrix.txt", sep = "\t", quote = FALSE)
  }

  #New version of complexheatmap complains about '' , replacing them with random string xxx
  mat[mat == ''] = 'xxx'


  #---------------------------------------Colors and vcs-------------------------------------------------

  #hard coded colors for variant classification if user doesnt provide any
  if(is.null(colors)){
    col = c(RColorBrewer::brewer.pal(12,name = "Paired"), RColorBrewer::brewer.pal(11,name = "Spectral")[1:3],'black', 'violet', 'royalblue')
    names(col) = names = c('Nonstop_Mutation','Frame_Shift_Del','IGR','Missense_Mutation','Silent','Nonsense_Mutation',
                           'RNA','Splice_Site','Intron','Frame_Shift_Ins','Nonstop_Mutation','In_Frame_Del','ITD','In_Frame_Ins',
                           'Translation_Start_Site',"Multi_Hit", 'Amp', 'Del')
  }else{
    col = colors
  }

  bg = "#CCCCCC" #Default gray background
  col = c(col, 'xxx' = bg)

  #Variant classes available in matrix
  variant.classes = unique(unlist(as.list(apply(mat_origin, 2, unique))))
  variant.classes = unique(unlist(strsplit(x = variant.classes, split = ';', fixed = TRUE)))
  variant.classes = variant.classes[!variant.classes %in% c('xxx')]

  type_col = structure(col[variant.classes], names = names(col[variant.classes]))
  type_col = type_col[!is.na(type_col)]

  type_name = structure(variant.classes, names = variant.classes)

  variant.classes = variant.classes[!variant.classes %in% c('Amp', 'Del')]

  #Variant classes available in plot matrix (We want to color code all vc's in colbar but only use those
  #in plot matrix for legend)
  vc.mat = unique(unlist(as.list(apply(mat, 2, unique))))
  vc.mat = unique(unlist(strsplit(x = vc.mat, split = ';', fixed = TRUE)))
  vc.mat = vc.mat[!vc.mat %in% c('xxx')]
  vc.type_name = structure(vc.mat, names = vc.mat)

  vc.type_col = structure(col[vc.mat], names = names(col[vc.mat]))
  vc.type_col = vc.type_col[!is.na(vc.type_col)]

  #annotation if given
  if(!is.null(annotationCols)){
    if(sortByMutation || sortByAnnotation){
      annotation = annotation[colnames(mat),, drop = FALSE]
    }

    if(!is.null(annotationColor)){
      bot.anno = ComplexHeatmap::HeatmapAnnotation(df = annotation, col = annotationColor)
    }else{
      bot.anno = ComplexHeatmap::HeatmapAnnotation(annotation)
    }
  }

  #------------------------------------functions to add %, rowbar and colbar----------------------------------------------------

  #------------------------------------------------------------------------------------------------------
  #Many thanks to Zuguang Gu (ComplexHeatmap) for letting me use the below code !
  #Modifed for maftools.
  #------------------------------------------------------------------------------------------------------

  ##This function adds percent rate
  anno_pct = function(index) {
    n = length(index)
    pct = apply(mat_origin[rev(index), ], 1, function(x) sum(!grepl("^\\s*$", x))/length(x)) * 100
    pct = paste0(round(pct), "%")
    grid::pushViewport(viewport(xscale = c(0, 1), yscale = c(0.5, n + 0.5)))
    grid::grid.text(pct, x = 1, y = seq_along(index), default.units = "native",
                    just = "right", gp = grid::gpar(fontsize = fontSize))
    grid::upViewport()
  }

  ha_pct = ComplexHeatmap::HeatmapAnnotation(pct = anno_pct,
                                             width = grid::grobWidth(grid::textGrob("100%", gp = grid::gpar(fontsize = 10))), which = "row")

  ##This function adds rowbar
  if(!is.null(mutsig)){
    anno_row_bar = function(index){
      n = length(index)

      max_count = max(as.numeric(as.character(ms.smg$FDR)))
      tb = rev(as.list(ms.smg$FDR))
      grid::pushViewport(grid::viewport(xscale = c(0, max_count * 1.1), yscale = c(0.5, n + 0.5)))
      for (i in seq_along(tb)) {
        if (length(tb[[i]])) {
          x = cumsum(tb[[i]])
          grid::grid.rect(x = x, i, width = tb[[i]], height = 0.8,
                          default.units = "native", just = "right",
                          gp = grid::gpar(col = NA, fill = "gray70"))
        }
      }
      breaks = grid::grid.pretty(c(0, max_count))
      grid::grid.xaxis(at = breaks, label = breaks, main = FALSE,
                       gp = grid::gpar(fontsize = 10))
      grid::upViewport()
    }
  }else{
    anno_row_bar = function(index) {
      n = length(index)

      tb = list()
      for(i in nrow(mat):1){
        x = mat[i,]
        x = x[x != '']
        x = x[x != 'xxx']
        x = unlist(strsplit(x, ";"))
        x = sort(x)
        tb[[i]] = table(x)
      }
      tb = rev(tb)

      max_count = max(sapply(tb, sum))
      grid::pushViewport(grid::viewport(xscale = c(0, max_count * 1.1), yscale = c(0.5, n + 0.5)))
      for (i in seq_along(tb)) {
        if (length(tb[[i]])) {
          x = cumsum(tb[[i]])
          grid::grid.rect(x = x, i, width = tb[[i]], height = 0.8,
                          default.units = "native", just = "right",
                          gp = grid::gpar(col = NA, fill = type_col[names(tb[[i]])]))
        }
      }
      breaks = grid::grid.pretty(c(0, max_count))
      grid::grid.xaxis(at = breaks, label = breaks, main = FALSE,
                       gp = grid::gpar(fontsize = 10))
      grid::upViewport()
    }
  }


  ha_row_bar = ComplexHeatmap::HeatmapAnnotation(row_bar = anno_row_bar,
                                                 width = grid::unit(4, "cm"), which = "row")

  ##This function adds columnbar
  anno_column_bar = function(index) {
    n = length(index)

    ss = getSampleSummary(x = maf)
    tb = ss[Tumor_Sample_Barcode %in% colnames(mat)]
    tb[,total := NULL]
    tb = split(tb, as.factor(as.character(tb$Tumor_Sample_Barcode)))
    tb = lapply(X = tb, function(x) unlist(x)[-1])
    tb = tb[colnames(mat)]

    max_count = max(sapply(tb, sum))

    grid::pushViewport(grid::viewport(yscale = c(0, max_count * 1.1),
                                      xscale = c(0.5, n + 0.5)))
    for (i in seq_along(tb)) {
      if (length(tb[[i]])) {
        y = cumsum(tb[[i]])
        grid::grid.rect(i, y, height = tb[[i]], width = 0.8,
                        default.units = "native", just = "top",
                        gp = grid::gpar(col = NA, fill = type_col[names(tb[[i]])]))
      }
    }
    breaks = grid::grid.pretty(c(0, max_count))
    grid::grid.yaxis(at = breaks, label = breaks, gp = grid::gpar(fontsize = 10))
    grid::upViewport()
  }

  ha_column_bar = ComplexHeatmap::HeatmapAnnotation(column_bar = anno_column_bar, which = "column")

  ##Following two funcs add grids
  add_oncoprint = function(type, x, y, width, height) {
    grid::grid.rect(x, y, width - unit(0.5, "mm"),
                    height - grid::unit(1, "mm"), gp = grid::gpar(col = NA, fill = bg))

    for (i in 1:length(variant.classes)) {
      if (any(type %in% variant.classes[i])) {
        grid::grid.rect(x, y, width - unit(0.5, "mm"), height -
                          grid::unit(1, "mm"), gp = grid::gpar(col = NA, fill = type_col[variant.classes[i]]))
      } else if (any(type %in% 'Amp')) {
        grid::grid.rect(x, y, width - unit(0.5, "mm"), height -
                          grid::unit(1, "mm"), gp = grid::gpar(col = NA, fill = bg))
        grid::grid.rect(x, y, width - unit(0.5, "mm"), height -
                          unit(15, 'mm'), gp = grid::gpar(col = NA, fill = type_col['Amp']))
      } else if (any(type %in% 'Del')) {
        grid::grid.rect(x, y, width - unit(0.5, "mm"), height -
                          grid::unit(1, "mm"), gp = grid::gpar(col = NA, fill = bg))
        grid::grid.rect(x, y, width - unit(0.5, "mm"), height - grid::unit(15, "mm")
                        , gp = grid::gpar(col = NA, fill = type_col['Del']))
      }
    }
  }

  add_oncoprint2 = function(type, x, y, width, height) {
    for (i in 1:length(variant.classes)) {
      if (any(type %in% variant.classes[i])) {
        grid::grid.rect(x, y, width - unit(0.5, "mm"), height -
                          grid::unit(1, "mm"), gp = grid::gpar(col = NA, fill = type_col[variant.classes[i]]))
      } else if (any(type %in% 'Amp')) {
        grid::grid.rect(x, y, width - unit(0.5, "mm"), height -
                          unit(15, 'mm'), gp = grid::gpar(col = NA, fill = type_col['Amp']))
      } else if (any(type %in% 'Del')) {

        grid::grid.rect(x, y, width - unit(0.5, "mm"), height - grid::unit(15, "mm")
                        , gp = grid::gpar(col = NA, fill = type_col['Del']))
      }
    }
  }

  #This is the main cel function which is passed to ComplexHeatmap::Hetamap()
  celFun = function(j, i, x, y, width, height, fill) {
    type = mat[i, j]
    if(type != 'xxx'){
      typeList = sort(unlist(strsplit(x = as.character(type), split = ';')), decreasing = TRUE)
      if(length(typeList) > 1){
        for(i in 1:length(typeList)){
          add_oncoprint2(typeList[i], x, y, width, height)
        }
      }else{
        for(i in 1:length(typeList)){
          add_oncoprint(typeList[i], x, y, width, height)
        }
      }

    }else{
      add_oncoprint(type, x, y, width, height)
    }
  }


  #----------------------------------------------------------------------------------------


  if(drawColBar){
    if(is.null(annotationCols)){

      ht = ComplexHeatmap::Heatmap(mat, na_col = bg,rect_gp = grid::gpar(type = "none"), cell_fun = celFun,
                                   row_names_gp = grid::gpar(fontsize = fontSize), show_column_names = showTumorSampleBarcodes,
                                   show_heatmap_legend = FALSE, top_annotation = ha_column_bar,
                                   top_annotation_height = grid::unit(2, "cm"))
    } else{

      ht = ComplexHeatmap::Heatmap(mat, na_col = bg,rect_gp = grid::gpar(type = "none"), cell_fun = celFun,
                                   row_names_gp = grid::gpar(fontsize = fontSize), show_column_names = showTumorSampleBarcodes,
                                   show_heatmap_legend = FALSE, top_annotation = ha_column_bar,
                                   top_annotation_height = grid::unit(2, "cm"), bottom_annotation = bot.anno)
    }

  } else{

    if(is.null(annotationCols)){

      ht = ComplexHeatmap::Heatmap(mat, na_col = bg, rect_gp = grid::gpar(type = "none"), cell_fun = celFun,
                                   row_names_gp = grid::gpar(fontsize = fontSize), show_column_names = showTumorSampleBarcodes, show_heatmap_legend = FALSE)
    }else{
      ht = ComplexHeatmap::Heatmap(mat, na_col = bg, rect_gp = grid::gpar(type = "none"), cell_fun = celFun,
                                   row_names_gp = grid::gpar(fontsize = fontSize), show_column_names = showTumorSampleBarcodes, show_heatmap_legend = FALSE, bottom_annotation = bot.anno)
    }
  }

  ha_pct = ComplexHeatmap::HeatmapAnnotation(pct = anno_pct,
                                             width = grid::grobWidth(grid::textGrob("100%", gp = grid::gpar(fontsize = 10))),
                                             which = "row")
  ht_list = ha_pct + ht


  if(drawRowBar){
    ht_list =  ht_list + ha_row_bar
  }

  legend = grid::legendGrob(labels = vc.type_name[names(vc.type_col)],  pch = 15, gp = grid::gpar(col = vc.type_col), nrow = 3)

  suppressWarnings( ComplexHeatmap::draw(ht_list, newpage = FALSE, annotation_legend_side = "bottom", annotation_legend_list = list(legend)) )
}
